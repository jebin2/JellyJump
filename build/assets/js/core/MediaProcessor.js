import{MediaBunny}from"./MediaBunny.js";export class MediaProcessor{static async process({source:e,format:o,quality:t,trim:n,resize:a,onProgress:r}){const i=new MediaBunny.BlobSource(e),s=new MediaBunny.Input({source:i,formats:MediaBunny.ALL_FORMATS});let c;switch(o){case"mp4":c=new MediaBunny.Mp4OutputFormat;break;case"webm":c=new MediaBunny.WebMOutputFormat;break;case"mov":c=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${o}`)}const d=new MediaBunny.Output({format:c,target:new MediaBunny.BufferTarget});let u=null;try{let e={};if(t<100){let o;o=t>=80?25e5:t>=60?15e5:8e5,e={bitrate:o,forceTranscode:!0}}return a&&a.width&&a.height&&(e.width=a.width,e.height=a.height,e.fit="fill",e.forceTranscode=!0),u=await MediaBunny.Conversion.init({input:s,output:d,video:e,trim:n}),r&&(u.onProgress=r),await u.execute(),new Blob([d.target.buffer],{type:`video/${o}`})}finally{if(u&&"function"==typeof u.dispose)try{u.dispose()}catch(e){console.warn("Error disposing conversion:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing output:",e)}if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing input:",e)}u=null}}static async getTracks(e){const o=new MediaBunny.BlobSource(e),t=new MediaBunny.Input({source:o,formats:MediaBunny.ALL_FORMATS});try{const e=await t.getVideoTracks(),o=await t.getAudioTracks(),n=async e=>Promise.all(e.map(async e=>{const o=await e.computeDuration(),t=await e.getCodecParameterString();return{id:e.id,type:e.type,language:e.languageCode,codec:e.codec,codecString:t,duration:o,width:e.displayWidth,height:e.displayHeight,channels:e.numberOfChannels,sampleRate:e.sampleRate}}));return{video:await n(e),audio:await n(o)}}finally{if(t&&"function"==typeof t.dispose)try{t.dispose()}catch(e){console.warn("Error disposing input in getTracks:",e)}}}static async extractTrack({source:e,trackIndex:o,trackType:t,format:n,onProgress:a}){const r=e instanceof Blob?new MediaBunny.BlobSource(e):new MediaBunny.BufferSource(e),i=new MediaBunny.Input({source:r,formats:MediaBunny.ALL_FORMATS});let s;switch(n){case"mp4":case"m4a":s=new MediaBunny.Mp4OutputFormat;break;case"mp3":s=new MediaBunny.Mp3OutputFormat;break;case"aac":s=new MediaBunny.AdtsOutputFormat;break;case"wav":s=new MediaBunny.WavOutputFormat;break;default:throw new Error(`Unsupported format: ${n}`)}const c=new MediaBunny.Output({format:s,target:new MediaBunny.BufferTarget});let d=null;try{const e={input:i,output:c,video:(e,n)=>{const a="video"===t&&n-1===o;return console.log(`[MediaProcessor] Video track ${n} (${e.codec}): ${a?"KEEP":"DISCARD"}`),a?{}:{discard:!0}},audio:(e,n)=>{const a="audio"===t&&n-1===o;return console.log(`[MediaProcessor] Audio track ${n} (${e.codec}): ${a?"KEEP":"DISCARD"}`),a?{}:{discard:!0}}};if(d=await MediaBunny.Conversion.init(e),!d.isValid){console.error("Conversion invalid:",d.discardedTracks);const e=d.discardedTracks.map(e=>`${e.track.type}: ${e.reason}`).join(", ");throw new Error(`Cannot execute conversion: ${e}`)}a&&(d.onProgress=a),await d.execute();const r="video"===t?`video/${n}`:`audio/${n}`;return new Blob([c.target.buffer],{type:r})}finally{if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing conversion in extractTrack:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing output in extractTrack:",e)}if(i&&"function"==typeof i.dispose)try{i.dispose()}catch(e){console.warn("Error disposing input in extractTrack:",e)}}}static async merge({inputs:e,format:o="mp4",resolution:t,onProgress:n}){if(!e||e.length<2)throw new Error("At least 2 videos are required for merging.");console.log("[MediaProcessor] Starting merge of",e.length,"videos");const a=[];let r=null,i=null,s=null;const c=document.createElement("canvas");try{console.log("[MediaProcessor] Step 1: Analyzing input videos...");const d=[];let u=0,l=0;for(let o=0;o<e.length;o++){const t=new MediaBunny.Input({source:new MediaBunny.BlobSource(e[o]),formats:MediaBunny.ALL_FORMATS});a.push(t);const r=await t.getPrimaryVideoTrack();if(!r)throw new Error(`No video track found in input file ${o+1}`);const i=await r.computeDuration(),s=r.displayWidth||r.codedWidth,c=r.displayHeight||r.codedHeight;console.log(`[MediaProcessor] Video ${o+1}: ${s}x${c}, ${i}s, codec: ${r.codec}`),u=Math.max(u,s),l=Math.max(l,c),d.push({index:o,input:t,width:s,height:c,duration:i,codec:r.codec}),n&&n((o+1)/(2*e.length))}const p=t?.width||u,f=t?.height||l,g=30;let w;switch(console.log(`[MediaProcessor] Target specs: ${p}x${f} @ ${g}fps`),console.log("[MediaProcessor] Step 2: Setting up output..."),o){case"mp4":w=new MediaBunny.Mp4OutputFormat;break;case"webm":w=new MediaBunny.WebMOutputFormat;break;case"mov":w=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${o}`)}r=new MediaBunny.Output({format:w,target:new MediaBunny.BufferTarget}),c.width=p,c.height=f;const m=c.getContext("2d");let y;i=new MediaBunny.CanvasSource(c,{codec:"webm"===o?"vp9":"avc",bitrate:5e6,frameRate:g}),r.addVideoTrack(i,{frameRate:g});let h=128e3;const M=48e3,B=2;if("webm"===o)y="opus";else{const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);0===e.length?(console.warn("[MediaProcessor] No supported audio codecs found, merge will be video-only"),y=null):(y=e[0],console.log(`[MediaProcessor] Using audio codec: ${y}`))}y&&(s=new MediaBunny.AudioSampleSource({codec:y,bitrate:h}),r.addAudioTrack(s),console.log(`[MediaProcessor] Audio output: ${B} channels @ ${M}Hz`)),await r.start();let $=0;for(let e=0;e<d.length;e++){console.log(`[MediaProcessor] Processing video ${e+1}/${d.length}...`);const o=d[e],t=o.input,a=await t.getPrimaryVideoTrack(),r=await t.getPrimaryAudioTrack();if(!await a.canDecode())throw new Error(`Cannot decode video ${e+1}. Codec ${a.codec} not supported.`);const c=new MediaBunny.VideoSampleSink(a),u=await a.getFirstTimestamp();let l=0;for await(const e of c.samples())try{const o=$+(e.timestamp-u),t=e.duration||1/g;m.fillStyle="black",m.fillRect(0,0,p,f);const n=Math.min(p/e.displayWidth,f/e.displayHeight),a=e.displayWidth*n,r=e.displayHeight*n,s=(p-a)/2,c=(f-r)/2;e.draw(m,s,c,a,r),await i.add(o,t),l++}finally{e.close()}if(console.log(`[MediaProcessor] Processed ${l} frames from video ${e+1}`),s&&r){if(await r.canDecode()){console.log(`[MediaProcessor] Processing audio from video ${e+1}...`);const o=new MediaBunny.AudioSampleSink(r),t=await r.getFirstTimestamp();let n=0;const a=r.sampleRate!==M,i=r.numberOfChannels!==B;(a||i)&&console.log(`[MediaProcessor] Audio conversion needed: ${r.numberOfChannels}ch @ ${r.sampleRate}Hz -> ${B}ch @ ${M}Hz`);for await(const e of o.samples()){const o=$+(e.timestamp-t);let r=e;if(a||i)try{const t=new OfflineAudioContext(B,Math.ceil(e.numberOfFrames*(M/e.sampleRate)),M),n=e.toAudioBuffer(),a=t.createBufferSource();a.buffer=n,a.connect(t.destination),a.start(0);const i=await t.startRendering(),s=MediaBunny.AudioSample.fromAudioBuffer(i,o);r=Array.isArray(s)?s[0]:s,e.close()}catch(o){throw console.error("[MediaProcessor] Error resampling audio:",o),e.close(),o}else r.setTimestamp(o);await s.add(r),r!==e&&r.close(),n++}console.log(`[MediaProcessor] Processed ${n} audio samples from video ${e+1}`)}else console.warn(`[MediaProcessor] Cannot decode audio from video ${e+1}, skipping`)}else!s&&r&&console.log("[MediaProcessor] No audio encoder available, skipping audio");if($+=o.duration,n){n(.5+(e+1)/(2*d.length))}}return console.log("[MediaProcessor] Finalizing merge..."),i.close(),s&&s.close(),await r.finalize(),n&&n(1),console.log("[MediaProcessor] Merge complete!"),new Blob([r.target.buffer],{type:`video/${o}`})}catch(e){throw console.error("[MediaProcessor] Merge failed:",e),new Error(`Video merge failed: ${e.message}`)}finally{if(console.log("[MediaProcessor] Cleaning up resources..."),r&&"function"==typeof r.dispose)try{r.dispose()}catch(e){console.warn("Error disposing output during merge cleanup:",e)}if(i&&"function"==typeof i.dispose)try{i.dispose()}catch(e){console.warn("Error disposing canvasSource during merge cleanup:",e)}if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing audioSource during merge cleanup:",e)}for(const e of a)if(e&&"function"==typeof e.dispose)try{e.dispose()}catch(e){console.warn("Error disposing input during merge cleanup:",e)}if(a.length=0,c){const e=c.getContext("2d");e&&e.clearRect(0,0,c.width,c.height)}r=null,i=null,s=null,console.log("[MediaProcessor] Cleanup complete")}}}