import{MediaBunny}from"./MediaBunny.js";export class MediaProcessor{static async process({source:e,format:o,quality:t,trim:n,resize:a,onProgress:i}){const r=new MediaBunny.BlobSource(e),s=new MediaBunny.Input({source:r,formats:MediaBunny.ALL_FORMATS});let c;switch(o){case"mp4":c=new MediaBunny.Mp4OutputFormat;break;case"webm":c=new MediaBunny.WebMOutputFormat;break;case"mov":c=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${o}`)}const d=new MediaBunny.Output({format:c,target:new MediaBunny.BufferTarget});let u=null;try{let e={};if(t<100){let o;o=t>=80?25e5:t>=60?15e5:8e5,e={bitrate:o,forceTranscode:!0}}return a&&a.width&&a.height&&(e.width=a.width,e.height=a.height,e.fit="fill",e.forceTranscode=!0),u=await MediaBunny.Conversion.init({input:s,output:d,video:e,trim:n}),i&&(u.onProgress=i),await u.execute(),new Blob([d.target.buffer],{type:`video/${o}`})}finally{if(u&&"function"==typeof u.dispose)try{u.dispose()}catch(e){console.warn("Error disposing conversion:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing output:",e)}if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing input:",e)}u=null}}static async getTracks(e){const o=new MediaBunny.BlobSource(e),t=new MediaBunny.Input({source:o,formats:MediaBunny.ALL_FORMATS});try{const e=await t.getVideoTracks(),o=await t.getAudioTracks(),n=async e=>Promise.all(e.map(async e=>{const o=await e.computeDuration(),t=await e.getCodecParameterString();return{id:e.id,type:e.type,language:e.languageCode,codec:e.codec,codecString:t,duration:o,width:e.displayWidth,height:e.displayHeight,channels:e.numberOfChannels,sampleRate:e.sampleRate}})),a=await n(e);return{video:a,audio:await n(o)}}finally{}}static async getMetadata(e){const o=new MediaBunny.BlobSource(e),t=new MediaBunny.Input({source:o,formats:MediaBunny.ALL_FORMATS});try{const e=await t.getVideoTracks(),o=await t.getAudioTracks();let n=null,a=null,i=0;if(e&&e.length>0){const o=e[0];i=await o.computeDuration(),n={width:o.width||o.displayWidth,height:o.height||o.displayHeight,displayWidth:o.displayWidth,displayHeight:o.displayHeight,codedWidth:o.codedWidth,codedHeight:o.codedHeight,codec:o.codec,rotation:o.rotation||0,hasHDR:!1}}if(o&&o.length>0){const e=o[0];i||(i=await e.computeDuration()),a={codec:e.codec,channels:e.numberOfChannels,sampleRate:e.sampleRate,languageCode:e.languageCode}}return{videoInfo:n,audioInfo:a,duration:i}}finally{if(t&&"function"==typeof t.dispose)try{t.dispose()}catch(e){console.warn("Error disposing input in getMetadata:",e)}}}static async extractTrack({source:e,trackIndex:o,trackType:t,format:n,onProgress:a}){const i=e instanceof Blob?new MediaBunny.BlobSource(e):new MediaBunny.BufferSource(e),r=new MediaBunny.Input({source:i,formats:MediaBunny.ALL_FORMATS});let s;switch(n){case"mp4":case"m4a":s=new MediaBunny.Mp4OutputFormat;break;case"mp3":s=new MediaBunny.Mp3OutputFormat;break;case"aac":s=new MediaBunny.AdtsOutputFormat;break;case"wav":s=new MediaBunny.WavOutputFormat;break;default:throw new Error(`Unsupported format: ${n}`)}const c=new MediaBunny.Output({format:s,target:new MediaBunny.BufferTarget});let d=null;try{const e={input:r,output:c,video:(e,n)=>{const a="video"===t&&n-1===o;return console.log(`[MediaProcessor] Video track ${n} (${e.codec}): ${a?"KEEP":"DISCARD"}`),a?{}:{discard:!0}},audio:(e,n)=>{const a="audio"===t&&n-1===o;return console.log(`[MediaProcessor] Audio track ${n} (${e.codec}): ${a?"KEEP":"DISCARD"}`),a?{}:{discard:!0}}};if(d=await MediaBunny.Conversion.init(e),!d.isValid){console.error("Conversion invalid:",d.discardedTracks);const e=d.discardedTracks.map(e=>`${e.track.type}: ${e.reason}`).join(", ");throw new Error(`Cannot execute conversion: ${e}`)}a&&(d.onProgress=a),await d.execute();const i="video"===t?`video/${n}`:`audio/${n}`;return new Blob([c.target.buffer],{type:i})}finally{if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing conversion in extractTrack:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing output in extractTrack:",e)}if(r&&"function"==typeof r.dispose)try{r.dispose()}catch(e){console.warn("Error disposing input in extractTrack:",e)}}}static _calculateScale(e,o,t,n,a){if("fill"===a)return{x:0,y:0,width:t,height:n};if("center"===a)return{x:(t-e)/2,y:(n-o)/2,width:e,height:o};const i=e/o;let r,s;return i>t/n?(r=t,s=t/i):(s=n,r=n*i),{x:(t-r)/2,y:(n-s)/2,width:r,height:s}}static async merge({inputs:e,format:o="mp4",resolution:t,scaleMode:n="proportional",backgroundColor:a="#000000",onProgress:i}){if(!e||e.length<2)throw new Error("At least 2 videos are required for merging.");console.log("[MediaProcessor] Starting merge of",e.length,"videos");const r=[];let s=null,c=null,d=null;const u=document.createElement("canvas");try{console.log("[MediaProcessor] Step 1: Analyzing input videos...");const l=[];let p=0,f=0;for(let o=0;o<e.length;o++){const t=new MediaBunny.Input({source:new MediaBunny.BlobSource(e[o]),formats:MediaBunny.ALL_FORMATS});r.push(t);const n=await t.getPrimaryVideoTrack();if(!n)throw new Error(`No video track found in input file ${o+1}`);const a=await n.computeDuration(),s=n.displayWidth||n.codedWidth,c=n.displayHeight||n.codedHeight;console.log(`[MediaProcessor] Video ${o+1}: ${s}x${c}, ${a}s, codec: ${n.codec}`),p=Math.max(p,s),f=Math.max(f,c),l.push({index:o,input:t,width:s,height:c,duration:a,codec:n.codec}),i&&i((o+1)/(2*e.length))}const g=t?.width||p,w=t?.height||f,y=30;let h;switch(console.log(`[MediaProcessor] Target specs: ${g}x${w} @ ${y}fps`),console.log("[MediaProcessor] Step 2: Setting up output..."),o){case"mp4":h=new MediaBunny.Mp4OutputFormat;break;case"webm":h=new MediaBunny.WebMOutputFormat;break;case"mov":h=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${o}`)}s=new MediaBunny.Output({format:h,target:new MediaBunny.BufferTarget}),u.width=g,u.height=w;const m=u.getContext("2d");let M;c=new MediaBunny.CanvasSource(u,{codec:"webm"===o?"vp9":"avc",bitrate:5e6,frameRate:y}),s.addVideoTrack(c,{frameRate:y});let B=128e3;const $=48e3,b=2;if("webm"===o)M="opus";else{const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);0===e.length?(console.warn("[MediaProcessor] No supported audio codecs found, merge will be video-only"),M=null):(M=e[0],console.log(`[MediaProcessor] Using audio codec: ${M}`))}M&&(d=new MediaBunny.AudioSampleSource({codec:M,bitrate:B}),s.addAudioTrack(d),console.log(`[MediaProcessor] Audio output: ${b} channels @ ${$}Hz`)),await s.start();let P=0;for(let e=0;e<l.length;e++){console.log(`[MediaProcessor] Processing video ${e+1}/${l.length}...`);const o=l[e],t=o.input,r=await t.getPrimaryVideoTrack(),s=await t.getPrimaryAudioTrack();if(!await r.canDecode())throw new Error(`Cannot decode video ${e+1}. Codec ${r.codec} not supported.`);const u=new MediaBunny.VideoSampleSink(r),p=await r.getFirstTimestamp();let f=0;for await(const e of u.samples())try{const o=P+(e.timestamp-p),t=e.duration||1/y;m.fillStyle=a,m.fillRect(0,0,g,w);const i=MediaProcessor._calculateScale(e.displayWidth,e.displayHeight,g,w,n);e.draw(m,i.x,i.y,i.width,i.height),await c.add(o,t),f++}finally{e.close()}if(console.log(`[MediaProcessor] Processed ${f} frames from video ${e+1}`),d&&s){if(await s.canDecode()){console.log(`[MediaProcessor] Processing audio from video ${e+1}...`);const o=new MediaBunny.AudioSampleSink(s),t=await s.getFirstTimestamp();let n=0;const a=s.sampleRate!==$,i=s.numberOfChannels!==b;(a||i)&&console.log(`[MediaProcessor] Audio conversion needed: ${s.numberOfChannels}ch @ ${s.sampleRate}Hz -> ${b}ch @ ${$}Hz`);for await(const e of o.samples()){const o=P+(e.timestamp-t);let r=e;if(a||i)try{const t=new OfflineAudioContext(b,Math.ceil(e.numberOfFrames*($/e.sampleRate)),$),n=e.toAudioBuffer(),a=t.createBufferSource();a.buffer=n,a.connect(t.destination),a.start(0);const i=await t.startRendering(),s=MediaBunny.AudioSample.fromAudioBuffer(i,o);r=Array.isArray(s)?s[0]:s,e.close()}catch(o){throw console.error("[MediaProcessor] Error resampling audio:",o),e.close(),o}else r.setTimestamp(o);await d.add(r),r!==e&&r.close(),n++}console.log(`[MediaProcessor] Processed ${n} audio samples from video ${e+1}`)}else console.warn(`[MediaProcessor] Cannot decode audio from video ${e+1}, skipping`)}else!d&&s&&console.log("[MediaProcessor] No audio encoder available, skipping audio");if(P+=o.duration,i){i(.5+(e+1)/(2*l.length))}}return console.log("[MediaProcessor] Finalizing merge..."),c.close(),d&&d.close(),await s.finalize(),i&&i(1),console.log("[MediaProcessor] Merge complete!"),new Blob([s.target.buffer],{type:`video/${o}`})}catch(e){throw console.error("[MediaProcessor] Merge failed:",e),new Error(`Video merge failed: ${e.message}`)}finally{if(console.log("[MediaProcessor] Cleaning up resources..."),s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing output during merge cleanup:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing canvasSource during merge cleanup:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing audioSource during merge cleanup:",e)}for(const e of r)if(e&&"function"==typeof e.dispose)try{e.dispose()}catch(e){console.warn("Error disposing input during merge cleanup:",e)}if(r.length=0,u){const e=u.getContext("2d");e&&e.clearRect(0,0,u.width,u.height)}s=null,c=null,d=null,console.log("[MediaProcessor] Cleanup complete")}}}