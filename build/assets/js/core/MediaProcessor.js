import{MediaBunny}from"./MediaBunny.js";import GIF from"../lib/gif.js";export class MediaProcessor{static _getBitrate(e,t){let o=80;"number"==typeof e?o=e:"high"===e?o=90:"medium"===e?o=60:"low"===e&&(o=30);let a=25e5*(t>0?t/921600:1)*(o/80);return Math.floor(Math.max(5e5,Math.min(5e7,a)))}static async process({source:e,format:t="mp4",quality:o="high",resolution:a=null,trim:n=null,removeBackgroundOptions:r=null,onProgress:i}){console.log("[MediaProcessor] Starting processing...",{format:t,quality:o,resolution:a,trim:n,removeBackgroundOptions:r});let s=null,c=null,d=null;r&&"transparent"===r.bgType&&(t="webm");try{let l;l="string"==typeof e?new MediaBunny.UrlSource(e):new MediaBunny.BlobSource(e),c=new MediaBunny.Input({source:l,formats:MediaBunny.ALL_FORMATS});const u=await c.getPrimaryVideoTrack();if(!u)throw new Error("No video track found");const p=u.displayWidth||u.codedWidth,f=u.displayHeight||u.codedHeight;let g;if("gif"===t)return this.createGif({source:e,trim:n,onProgress:i});g="webm"===t?new MediaBunny.WebMOutputFormat:new MediaBunny.Mp4OutputFormat,d=new MediaBunny.Output({format:g,target:new MediaBunny.BufferTarget});const m={codec:"webm"===t?"vp9":"avc",bitrate:this._getBitrate(o,p*f),forceTranscode:!0};a&&(m.width=a.width,m.height=a.height,m.fit="fill");const y="undefined"!=typeof OffscreenCanvas;let h=null,w=null;m.process=e=>{if(!r)return e;const t=e.codedWidth,o=e.codedHeight;h&&h.width===t&&h.height===o||(y?h=new OffscreenCanvas(t,o):(h=document.createElement("canvas"),h.width=t,h.height=o),w=h.getContext("2d",{willReadFrequently:!0})),w.clearRect(0,0,t,o),e.draw(w,0,0,t,o);const a=w.getImageData(0,0,t,o);if(r){const{colors:e,bgType:t,bgColor:o}=r;MediaProcessor.applyChromaKey(a,e,t,o)}return w.putImageData(a,0,0),h};const M={input:c,output:d,video:m};return n&&(M.trim=n),s=await MediaBunny.Conversion.init(M),i&&(s.onProgress=i),await s.execute(),new Blob([d.target.buffer],{type:`video/${t}`})}finally{if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing conversion:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing output:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing input:",e)}s=null}}static async getVideoStats(e,t=50){const o=new MediaBunny.BlobSource(e),a=new MediaBunny.Input({source:o,formats:MediaBunny.ALL_FORMATS});try{const e=await a.getPrimaryVideoTrack();return e?await e.computePacketStats(t):null}finally{if(a&&"function"==typeof a.dispose)try{a.dispose()}catch(e){console.warn("Error disposing input in getVideoStats:",e)}}}static async _getTrackDetails(e){const t=await e.getVideoTracks(),o=await e.getAudioTracks(),a=async e=>Promise.all(e.map(async e=>{const t=await e.computeDuration(),o=await e.getCodecParameterString();return{id:e.id,type:e.type,language:e.languageCode,codec:e.codec,codecString:o,duration:t,width:e.width||e.displayWidth,height:e.height||e.displayHeight,displayWidth:e.displayWidth,displayHeight:e.displayHeight,codedWidth:e.codedWidth,codedHeight:e.codedHeight,rotation:e.rotation||0,channels:e.numberOfChannels,sampleRate:e.sampleRate,_track:e}}));return{video:await a(t),audio:await a(o)}}static async getMetadata(e){let t;t="string"==typeof e?new MediaBunny.UrlSource(e):new MediaBunny.BlobSource(e);const o=new MediaBunny.Input({source:t,formats:MediaBunny.ALL_FORMATS});try{const{video:e,audio:t}=await this._getTrackDetails(o);let a=null,n=null,r=0;if(e&&e.length>0){const t=e[0],o=t._track;r=t.duration,a={width:t.width,height:t.height,displayWidth:o.displayWidth,displayHeight:o.displayHeight,codedWidth:o.codedWidth,codedHeight:o.codedHeight,codec:t.codec,rotation:o.rotation||0,hasHDR:!1};try{const e=await o.computePacketStats(50);a.fps=Math.round(e.averagePacketRate),a.bitrate=e.averageBitrate}catch(e){console.warn("Failed to compute packet stats:",e),a.fps=0,a.bitrate=0}}if(t&&t.length>0){const e=t[0];r||(r=e.duration),n={codec:e.codec,channels:e.channels,sampleRate:e.sampleRate,languageCode:e.language}}const i=e.map(e=>{const{_track:t,...o}=e;return o});return{videoInfo:a,audioInfo:n,duration:r,videoTracks:i,audioTracks:t.map(e=>{const{_track:t,...o}=e;return o})}}finally{if(o&&"function"==typeof o.dispose)try{o.dispose()}catch(e){console.warn("Error disposing input in getMetadata:",e)}}}static async extractTrack({source:e,trackIndex:t,trackType:o,format:a,speed:n=1,onProgress:r}){const i=Math.max(.25,Math.min(2,n));return 1===i?this._extractTrackStreamCopy({source:e,trackIndex:t,trackType:o,format:a,onProgress:r}):this._extractTrackWithSpeed({source:e,trackIndex:t,trackType:o,format:a,speed:i,onProgress:r})}static async _extractTrackStreamCopy({source:e,trackIndex:t,trackType:o,format:a,onProgress:n}){const r=e instanceof Blob?new MediaBunny.BlobSource(e):new MediaBunny.BufferSource(e),i=new MediaBunny.Input({source:r,formats:MediaBunny.ALL_FORMATS});let s;switch(a){case"mp4":case"m4a":s=new MediaBunny.Mp4OutputFormat;break;case"mp3":s=new MediaBunny.Mp3OutputFormat;break;case"aac":s=new MediaBunny.AdtsOutputFormat;break;case"wav":s=new MediaBunny.WavOutputFormat;break;default:throw new Error(`Unsupported format: ${a}`)}const c=new MediaBunny.Output({format:s,target:new MediaBunny.BufferTarget});let d=null;try{const e={input:i,output:c,video:(e,a)=>{const n="video"===o&&a-1===t;return console.log(`[MediaProcessor] Video track ${a} (${e.codec}): ${n?"KEEP":"DISCARD"}`),n?{}:{discard:!0}},audio:(e,a)=>{const n="audio"===o&&a-1===t;return console.log(`[MediaProcessor] Audio track ${a} (${e.codec}): ${n?"KEEP":"DISCARD"}`),n?{}:{discard:!0}}};if(d=await MediaBunny.Conversion.init(e),!d.isValid){console.error("Conversion invalid:",d.discardedTracks);const e=d.discardedTracks.map(e=>`${e.track.type}: ${e.reason}`).join(", ");throw new Error(`Cannot execute conversion: ${e}`)}n&&(d.onProgress=n),await d.execute();const r="video"===o?`video/${a}`:`audio/${a}`;return new Blob([c.target.buffer],{type:r})}finally{if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing conversion in extractTrack:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing output in extractTrack:",e)}if(i&&"function"==typeof i.dispose)try{i.dispose()}catch(e){console.warn("Error disposing input in extractTrack:",e)}}}static async _extractTrackWithSpeed({source:e,trackIndex:t,trackType:o,format:a,speed:n,onProgress:r}){console.log(`[MediaProcessor] Extracting ${o} track ${t} with speed ${n}x`);const i=e instanceof Blob?new MediaBunny.BlobSource(e):new MediaBunny.BufferSource(e),s=new MediaBunny.Input({source:i,formats:MediaBunny.ALL_FORMATS});let c=null,d=null,l=null,u=null;try{if("video"===o){const e=await s.getVideoTracks();if(t>=e.length)throw new Error(`Video track ${t} not found`);const o=e[t],i=o.displayWidth||o.codedWidth,l=o.displayHeight||o.codedHeight,p=await o.computeDuration(),f=await o.getFirstTimestamp();let g=30;try{g=(await o.computePacketStats()).averagePacketRate||30}catch(e){console.warn("[MediaProcessor] Could not compute frame rate, defaulting to 30fps")}const m=p/n,y=g,h=1/y,w=Math.ceil(m*y);console.log(`[MediaProcessor] Video: ${i}x${l}, ${p.toFixed(2)}s -> ${m.toFixed(2)}s at ${n}x`);const M="webm"===a?new MediaBunny.WebMOutputFormat:new MediaBunny.Mp4OutputFormat;c=new MediaBunny.Output({format:M,target:new MediaBunny.BufferTarget}),u=document.createElement("canvas"),u.width=i,u.height=l;const B=u.getContext("2d",{willReadFrequently:!0});d=new MediaBunny.CanvasSource(u,{codec:"webm"===a?"vp9":"avc",bitrate:5e6,frameRate:y}),c.addVideoTrack(d,{frameRate:y}),await c.start();const k=new MediaBunny.VideoSampleSink(o),v=async function*(){for(let e=0;e<w;e++){const t=p*(e/w);yield f+t}}();let P=0,b=0;for await(const e of k.samplesAtTimestamps(v))e&&(e.draw(B,0,0,i,l),await d.add(P,h),P+=h,e.close(),b++,r&&r(b/w));return console.log(`[MediaProcessor] Encoded ${b} video frames`),d.close(),await c.finalize(),new Blob([c.target.buffer],{type:`video/${a}`})}{const e=await s.getAudioTracks();if(t>=e.length)throw new Error(`Audio track ${t} not found`);const o=e[t],i=new MediaBunny.AudioSampleSink(o),d=[];for await(const e of i.samples())d.push(e);let u;switch(console.log(`[MediaProcessor] Collected ${d.length} audio samples for speed adjustment`),a){case"m4a":default:u=new MediaBunny.Mp4OutputFormat;break;case"mp3":u=new MediaBunny.Mp3OutputFormat;break;case"wav":u=new MediaBunny.WavOutputFormat}c=new MediaBunny.Output({format:u,target:new MediaBunny.BufferTarget});const p=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);if(0===p.length)throw new Error("No supported audio codecs found");l=new MediaBunny.AudioSampleSource({codec:p[0],bitrate:128e3}),c.addAudioTrack(l),await c.start();let f=0;const g=d.length;for(let e=0;e<d.length;e++){const t=d[e],o=t.toAudioBuffer();let a=o;try{const e=o.duration/n,t=Math.ceil(e*o.sampleRate),r=new OfflineAudioContext(o.numberOfChannels,t,o.sampleRate),i=r.createBufferSource();i.buffer=o,i.playbackRate.value=n,i.connect(r.destination),i.start(0),a=await r.startRendering()}catch(e){console.warn("[MediaProcessor] Audio time-stretch failed, using original:",e)}const i=MediaBunny.AudioSample.fromAudioBuffer(a,f),s=Array.isArray(i)?i:[i];for(const e of s)await l.add(e),f+=e.duration,e.close();t.close(),r&&e%100==0&&r(e/g)}return console.log("[MediaProcessor] Audio speed adjustment complete"),l.close(),await c.finalize(),r&&r(1),new Blob([c.target.buffer],{type:`audio/${a}`})}}finally{if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing input:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing output:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing canvasSource:",e)}if(l&&"function"==typeof l.dispose)try{l.dispose()}catch(e){console.warn("Error disposing audioSource:",e)}}}static _calculateScale(e,t,o,a,n){if("fill"===n)return{x:0,y:0,width:o,height:a};if("center"===n)return{x:(o-e)/2,y:(a-t)/2,width:e,height:t};const r=e/t;let i,s;return r>o/a?(i=o,s=o/r):(s=a,i=a*r),{x:(o-i)/2,y:(a-s)/2,width:i,height:s}}static async merge({inputs:e,format:t="mp4",resolution:o,scaleMode:a="proportional",backgroundColor:n="#000000",onProgress:r}){if(!e||e.length<2)throw new Error("At least 2 videos are required for merging.");console.log("[MediaProcessor] Starting merge of",e.length,"videos");const i=[];let s=null,c=null,d=null;const l=document.createElement("canvas");try{console.log("[MediaProcessor] Step 1: Analyzing input videos...");const u=[];let p=0,f=0;for(let t=0;t<e.length;t++){const o=new MediaBunny.Input({source:new MediaBunny.BlobSource(e[t]),formats:MediaBunny.ALL_FORMATS});i.push(o);const a=await o.getPrimaryVideoTrack();if(!a)throw new Error(`No video track found in input file ${t+1}`);const n=await a.computeDuration(),s=a.displayWidth||a.codedWidth,c=a.displayHeight||a.codedHeight;console.log(`[MediaProcessor] Video ${t+1}: ${s}x${c}, ${n}s, codec: ${a.codec}`),p=Math.max(p,s),f=Math.max(f,c),u.push({index:t,input:o,width:s,height:c,duration:n,codec:a.codec}),r&&r((t+1)/(2*e.length))}const g=o?.width||p,m=o?.height||f,y=30;let h;switch(console.log(`[MediaProcessor] Target specs: ${g}x${m} @ ${y}fps`),console.log("[MediaProcessor] Step 2: Setting up output..."),t){case"mp4":h=new MediaBunny.Mp4OutputFormat;break;case"webm":h=new MediaBunny.WebMOutputFormat;break;case"mov":h=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${t}`)}s=new MediaBunny.Output({format:h,target:new MediaBunny.BufferTarget}),l.width=g,l.height=m;const w=l.getContext("2d");let M;c=new MediaBunny.CanvasSource(l,{codec:"webm"===t?"vp9":"avc",bitrate:5e6,frameRate:y}),s.addVideoTrack(c,{frameRate:y});let B=128e3;const k=48e3,v=2;if("webm"===t)M="opus";else{const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);0===e.length?(console.warn("[MediaProcessor] No supported audio codecs found, merge will be video-only"),M=null):(M=e[0],console.log(`[MediaProcessor] Using audio codec: ${M}`))}M&&(d=new MediaBunny.AudioSampleSource({codec:M,bitrate:B}),s.addAudioTrack(d),console.log(`[MediaProcessor] Audio output: ${v} channels @ ${k}Hz`)),await s.start();let P=0;for(let e=0;e<u.length;e++){console.log(`[MediaProcessor] Processing video ${e+1}/${u.length}...`);const t=u[e],o=t.input,i=await o.getPrimaryVideoTrack(),s=await o.getPrimaryAudioTrack();if(!await i.canDecode())throw new Error(`Cannot decode video ${e+1}. Codec ${i.codec} not supported.`);const l=new MediaBunny.VideoSampleSink(i),p=await i.getFirstTimestamp();let f=0;for await(const e of l.samples())try{const t=P+(e.timestamp-p),o=e.duration||1/y;w.fillStyle=n,w.fillRect(0,0,g,m);const r=MediaProcessor._calculateScale(e.displayWidth,e.displayHeight,g,m,a);e.draw(w,r.x,r.y,r.width,r.height),await c.add(t,o),f++}finally{e.close()}if(console.log(`[MediaProcessor] Processed ${f} frames from video ${e+1}`),d&&s){if(await s.canDecode()){console.log(`[MediaProcessor] Processing audio from video ${e+1}...`);const t=new MediaBunny.AudioSampleSink(s),o=await s.getFirstTimestamp();let a=0;const n=s.sampleRate!==k,r=s.numberOfChannels!==v;(n||r)&&console.log(`[MediaProcessor] Audio conversion needed: ${s.numberOfChannels}ch @ ${s.sampleRate}Hz -> ${v}ch @ ${k}Hz`);for await(const e of t.samples()){const t=P+(e.timestamp-o);let i=e;if(n||r)try{const o=new OfflineAudioContext(v,Math.ceil(e.numberOfFrames*(k/e.sampleRate)),k),a=e.toAudioBuffer(),n=o.createBufferSource();n.buffer=a,n.connect(o.destination),n.start(0);const r=await o.startRendering(),s=MediaBunny.AudioSample.fromAudioBuffer(r,t);i=Array.isArray(s)?s[0]:s,e.close()}catch(t){throw console.error("[MediaProcessor] Error resampling audio:",t),e.close(),t}else i.setTimestamp(t);await d.add(i),i!==e&&i.close(),a++}console.log(`[MediaProcessor] Processed ${a} audio samples from video ${e+1}`)}else console.warn(`[MediaProcessor] Cannot decode audio from video ${e+1}, skipping`)}else!d&&s&&console.log("[MediaProcessor] No audio encoder available, skipping audio");if(P+=t.duration,r){r(.5+(e+1)/(2*u.length))}}return console.log("[MediaProcessor] Finalizing merge..."),c.close(),d&&d.close(),await s.finalize(),r&&r(1),console.log("[MediaProcessor] Merge complete!"),new Blob([s.target.buffer],{type:`video/${t}`})}catch(e){throw console.error("[MediaProcessor] Merge failed:",e),new Error(`Video merge failed: ${e.message}`)}finally{if(console.log("[MediaProcessor] Cleaning up resources..."),s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing output during merge cleanup:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing canvasSource during merge cleanup:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing audioSource during merge cleanup:",e)}for(const e of i)if(e&&"function"==typeof e.dispose)try{e.dispose()}catch(e){console.warn("Error disposing input during merge cleanup:",e)}if(i.length=0,l){const e=l.getContext("2d");e&&e.clearRect(0,0,l.width,l.height)}s=null,c=null,d=null,console.log("[MediaProcessor] Cleanup complete")}}static async createGif(e){const{input:t,startTime:o,duration:a,fps:n,width:r,height:i,quality:s,onProgress:c}=e,d=document.createElement("video");d.muted=!0,d.playsInline=!0;const l=URL.createObjectURL(t);d.src=l;try{await new Promise((e,t)=>{d.onloadedmetadata=e,d.onerror=t});const e=document.createElement("canvas");e.width=r,e.height=i;const t=e.getContext("2d",{willReadFrequently:!0}),l=new GIF({workers:2,quality:Math.max(1,Math.round((100-s)/10)),workerScript:"assets/js/lib/gif.worker.js",width:r,height:i}),u=Math.round(1e3/n),p=Math.ceil(a*n),f=a/p;let g=0;for(let a=0;a<p;a++){const n=o+a*f;d.currentTime=n,await new Promise(e=>{d.onseeked=e}),t.drawImage(d,0,0,r,i),l.addFrame(e,{delay:u,copy:!0}),g++,c&&c(g/p*.5)}return new Promise((e,t)=>{l.on("finished",t=>{c&&c(1),e(t)}),l.on("progress",e=>{c&&c(.5+.5*e)}),l.on("error",t),l.render()})}finally{URL.revokeObjectURL(l),d.src="",d.load()}}static async reverseVideo({source:e,includeAudio:t=!1,speed:o=1,onProgress:a}){console.log("[MediaProcessor] Starting video reversal with samplesAtTimestamps...");const n=new MediaBunny.BlobSource(e),r=new MediaBunny.Input({source:n,formats:MediaBunny.ALL_FORMATS});let i=null,s=null,c=null,d=null;try{const e=await r.getPrimaryVideoTrack();if(!e)throw new Error("No video track found");const n=e.displayWidth||e.codedWidth,l=e.displayHeight||e.codedHeight,u=await e.computeDuration(),p=await e.getFirstTimestamp();let f=30;try{f=(await e.computePacketStats()).averagePacketRate||30}catch(e){console.warn("[MediaProcessor] Could not compute frame rate, defaulting to 30fps",e)}const g=Math.max(.25,Math.min(2,o)),m=f,y=u,h=y/g,w=1/m,M=Math.ceil(h*m);console.log(`[MediaProcessor] Source: ${n}x${l}, ${u.toFixed(2)}s, ${f.toFixed(1)}fps`),console.log(`[MediaProcessor] Speed: ${g}x, Output: ${h.toFixed(2)}s, ${M} frames`);const B=new MediaBunny.Mp4OutputFormat;i=new MediaBunny.Output({format:B,target:new MediaBunny.BufferTarget}),d=document.createElement("canvas"),d.width=n,d.height=l;const k=d.getContext("2d",{willReadFrequently:!0});if(s=new MediaBunny.CanvasSource(d,{codec:"avc",bitrate:5e6,frameRate:m}),i.addVideoTrack(s,{frameRate:m}),t){if(await r.getPrimaryAudioTrack()){const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);e.length>0&&(c=new MediaBunny.AudioSampleSource({codec:e[0],bitrate:128e3}),i.addAudioTrack(c))}}await i.start(),console.log("[MediaProcessor] Extracting frames in reverse order using samplesAtTimestamps...");const v=new MediaBunny.VideoSampleSink(e),P=async function*(){for(let e=0;e<M;e++){const t=y*(1-e/M);yield p+t}}();let b=0,S=0;for await(const e of v.samplesAtTimestamps(P))e&&(e.draw(k,0,0,n,l),await s.add(b,w),b+=w,e.close(),S++,a&&a(S/M*.8));if(console.log(`[MediaProcessor] Encoded ${S} frames`),t&&c){console.log("[MediaProcessor] Reversing audio...");try{const e=await r.getPrimaryAudioTrack();e&&(await MediaProcessor._reverseAudioWithSink(e,c,u,g,a),console.log("[MediaProcessor] Audio reversal complete"))}catch(e){console.warn("[MediaProcessor] Audio reversal failed:",e)}}return console.log("[MediaProcessor] Finalizing..."),s.close(),c&&c.close(),await i.finalize(),a&&a(1),console.log("[MediaProcessor] Reverse complete!"),new Blob([i.target.buffer],{type:"video/mp4"})}finally{if(r&&"function"==typeof r.dispose)try{r.dispose()}catch(e){console.warn("Error disposing input:",e)}if(i&&"function"==typeof i.dispose)try{i.dispose()}catch(e){console.warn("Error disposing output:",e)}if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing canvasSource:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing audioSource:",e)}}}static async _reverseAudioWithSink(e,t,o,a=1,n){const r=new MediaBunny.AudioSampleSink(e),i=[];for await(const e of r.samples())i.push(e);console.log(`[MediaProcessor] Collected ${i.length} audio samples`),i.reverse();let s=0;const c=i.length;for(let e=0;e<i.length;e++){const o=i[e],r=o.toAudioBuffer();for(let e=0;e<r.numberOfChannels;e++){r.getChannelData(e).reverse()}let d=r;if(1!==a)try{const e=r.duration/a,t=Math.ceil(e*r.sampleRate),o=new OfflineAudioContext(r.numberOfChannels,t,r.sampleRate),n=o.createBufferSource();n.buffer=r,n.playbackRate.value=a,n.connect(o.destination),n.start(0),d=await o.startRendering()}catch(e){console.warn("[MediaProcessor] Audio time-stretch failed, using original:",e)}const l=MediaBunny.AudioSample.fromAudioBuffer(d,s),u=Array.isArray(l)?l:[l];for(const e of u)await t.add(e),s+=e.duration,e.close();o.close(),n&&e%100==0&&n(.8+e/c*.2)}}static async _reverseAudioInChunks(e,t,o,a){const n=Math.ceil(o/5),r=new AudioContext;try{const i=await e.arrayBuffer(),s=await r.decodeAudioData(i),c=s.sampleRate,d=s.numberOfChannels;console.log(`[MediaProcessor] Audio: ${d} channels @ ${c}Hz`);let l=0;for(let e=n-1;e>=0;e--){const i=5*e,u=Math.min(i+5,o),p=Math.floor(i*c),f=Math.min(Math.floor(u*c),s.length),g=f-p;if(g<=0)continue;const m=r.createBuffer(d,g,c);for(let e=0;e<d;e++){const t=s.getChannelData(e),o=m.getChannelData(e);for(let e=0;e<g;e++)o[e]=t[f-1-e]}const y=MediaBunny.AudioSample.fromAudioBuffer(m,l),h=Array.isArray(y)?y:[y];for(const e of h)await t.add(e),l+=e.duration,e.close();if(a){a(.8+.2*((n-e)/n))}}}finally{await r.close()}}static applyChromaKey(e,t,o="transparent",a="#000000"){const n=e.data;e.width,e.height;let r=0,i=0,s=0;if("custom"===o){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);e&&(r=parseInt(e[1],16),i=parseInt(e[2],16),s=parseInt(e[3],16))}const c=t.map(e=>({r:e.r,g:e.g,b:e.b,similarity:void 0!==e.similarity?e.similarity:0,smoothness:void 0!==e.smoothness?e.smoothness:.08,spill:void 0!==e.spill?e.spill:.1}));for(let e=0;e<n.length;e+=4){const t=n[e],a=n[e+1],d=n[e+2];let l=1,u=t,p=a,f=d;for(const e of c){const o=Math.sqrt((t-e.r)**2+(a-e.g)**2+(d-e.b)**2)/441.67;let n=1;if(o<e.similarity?n=0:o<e.similarity+e.smoothness&&(n=(o-e.similarity)/e.smoothness),n<l&&(l=n,n<1&&e.spill>0)){const n=.299*t+.587*a+.114*d,r=e.spill*(1-o);r>0&&(u=t*(1-r)+n*r,p=a*(1-r)+n*r,f=d*(1-r)+n*r)}}"transparent"===o?(n[e]=u,n[e+1]=p,n[e+2]=f,n[e+3]=255*l):(n[e]=u*l+r*(1-l),n[e+1]=p*l+i*(1-l),n[e+2]=f*l+s*(1-l),n[e+3]=255)}}}