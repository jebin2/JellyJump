import{MediaBunny}from"./MediaBunny.js";import GIF from"../lib/gif.js";export class MediaProcessor{static _getBitrate(e,o){let t=80;"number"==typeof e?t=e:"high"===e?t=90:"medium"===e?t=60:"low"===e&&(t=30);let a=25e5*(o>0?o/921600:1)*(t/80);return Math.floor(Math.max(5e5,Math.min(5e7,a)))}static async process({source:e,format:o="mp4",quality:t="high",resolution:a=null,trim:n=null,removeBackgroundOptions:i=null,onProgress:r}){console.log("[MediaProcessor] Starting processing...",{format:o,quality:t,resolution:a,trim:n,removeBackgroundOptions:i});let s=null,c=null,d=null;i&&"transparent"===i.bgType&&(o="webm");try{const l=new MediaBunny.BlobSource(e);c=new MediaBunny.Input({source:l,formats:MediaBunny.ALL_FORMATS});const u=await c.getPrimaryVideoTrack();if(!u)throw new Error("No video track found");const p=u.displayWidth||u.codedWidth,f=u.displayHeight||u.codedHeight;let g;if("gif"===o)return this.createGif({source:e,trim:n,onProgress:r});g="webm"===o?new MediaBunny.WebMOutputFormat:new MediaBunny.Mp4OutputFormat,d=new MediaBunny.Output({format:g,target:new MediaBunny.BufferTarget});const m={codec:"webm"===o?"vp9":"avc",bitrate:this._getBitrate(t,p*f),forceTranscode:!0};a&&(m.width=a.width,m.height=a.height,m.fit="fill");const h="undefined"!=typeof OffscreenCanvas;let y=null,w=null;m.process=e=>{if(!i)return e;const o=e.codedWidth,t=e.codedHeight;y&&y.width===o&&y.height===t||(h?y=new OffscreenCanvas(o,t):(y=document.createElement("canvas"),y.width=o,y.height=t),w=y.getContext("2d",{willReadFrequently:!0})),w.clearRect(0,0,o,t),e.draw(w,0,0,o,t);const a=w.getImageData(0,0,o,t);if(i){const{colors:e,bgType:o,bgColor:t}=i;MediaProcessor.applyChromaKey(a,e,o,t)}return w.putImageData(a,0,0),y};const M={input:c,output:d,video:m};return n&&(M.trim=n),s=await MediaBunny.Conversion.init(M),r&&(s.onProgress=r),await s.execute(),new Blob([d.target.buffer],{type:`video/${o}`})}finally{if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing conversion:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing output:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing input:",e)}s=null}}static async getVideoStats(e,o=50){const t=new MediaBunny.BlobSource(e),a=new MediaBunny.Input({source:t,formats:MediaBunny.ALL_FORMATS});try{const e=await a.getPrimaryVideoTrack();return e?await e.computePacketStats(o):null}finally{if(a&&"function"==typeof a.dispose)try{a.dispose()}catch(e){console.warn("Error disposing input in getVideoStats:",e)}}}static async _getTrackDetails(e){const o=await e.getVideoTracks(),t=await e.getAudioTracks(),a=async e=>Promise.all(e.map(async e=>{const o=await e.computeDuration(),t=await e.getCodecParameterString();return{id:e.id,type:e.type,language:e.languageCode,codec:e.codec,codecString:t,duration:o,width:e.width||e.displayWidth,height:e.height||e.displayHeight,displayWidth:e.displayWidth,displayHeight:e.displayHeight,codedWidth:e.codedWidth,codedHeight:e.codedHeight,rotation:e.rotation||0,channels:e.numberOfChannels,sampleRate:e.sampleRate,_track:e}}));return{video:await a(o),audio:await a(t)}}static async getMetadata(e){let o;o="string"==typeof e?new MediaBunny.UrlSource(e):new MediaBunny.BlobSource(e);const t=new MediaBunny.Input({source:o,formats:MediaBunny.ALL_FORMATS});try{const{video:e,audio:o}=await this._getTrackDetails(t);let a=null,n=null,i=0;if(e&&e.length>0){const o=e[0],t=o._track;i=o.duration,a={width:o.width,height:o.height,displayWidth:t.displayWidth,displayHeight:t.displayHeight,codedWidth:t.codedWidth,codedHeight:t.codedHeight,codec:o.codec,rotation:t.rotation||0,hasHDR:!1};try{const e=await t.computePacketStats(50);a.fps=Math.round(e.averagePacketRate),a.bitrate=e.averageBitrate}catch(e){console.warn("Failed to compute packet stats:",e),a.fps=0,a.bitrate=0}}if(o&&o.length>0){const e=o[0];i||(i=e.duration),n={codec:e.codec,channels:e.channels,sampleRate:e.sampleRate,languageCode:e.language}}const r=e.map(e=>{const{_track:o,...t}=e;return t});return{videoInfo:a,audioInfo:n,duration:i,videoTracks:r,audioTracks:o.map(e=>{const{_track:o,...t}=e;return t})}}finally{if(t&&"function"==typeof t.dispose)try{t.dispose()}catch(e){console.warn("Error disposing input in getMetadata:",e)}}}static async extractTrack({source:e,trackIndex:o,trackType:t,format:a,onProgress:n}){const i=e instanceof Blob?new MediaBunny.BlobSource(e):new MediaBunny.BufferSource(e),r=new MediaBunny.Input({source:i,formats:MediaBunny.ALL_FORMATS});let s;switch(a){case"mp4":case"m4a":s=new MediaBunny.Mp4OutputFormat;break;case"mp3":s=new MediaBunny.Mp3OutputFormat;break;case"aac":s=new MediaBunny.AdtsOutputFormat;break;case"wav":s=new MediaBunny.WavOutputFormat;break;default:throw new Error(`Unsupported format: ${a}`)}const c=new MediaBunny.Output({format:s,target:new MediaBunny.BufferTarget});let d=null;try{const e={input:r,output:c,video:(e,a)=>{const n="video"===t&&a-1===o;return console.log(`[MediaProcessor] Video track ${a} (${e.codec}): ${n?"KEEP":"DISCARD"}`),n?{}:{discard:!0}},audio:(e,a)=>{const n="audio"===t&&a-1===o;return console.log(`[MediaProcessor] Audio track ${a} (${e.codec}): ${n?"KEEP":"DISCARD"}`),n?{}:{discard:!0}}};if(d=await MediaBunny.Conversion.init(e),!d.isValid){console.error("Conversion invalid:",d.discardedTracks);const e=d.discardedTracks.map(e=>`${e.track.type}: ${e.reason}`).join(", ");throw new Error(`Cannot execute conversion: ${e}`)}n&&(d.onProgress=n),await d.execute();const i="video"===t?`video/${a}`:`audio/${a}`;return new Blob([c.target.buffer],{type:i})}finally{if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing conversion in extractTrack:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing output in extractTrack:",e)}if(r&&"function"==typeof r.dispose)try{r.dispose()}catch(e){console.warn("Error disposing input in extractTrack:",e)}}}static _calculateScale(e,o,t,a,n){if("fill"===n)return{x:0,y:0,width:t,height:a};if("center"===n)return{x:(t-e)/2,y:(a-o)/2,width:e,height:o};const i=e/o;let r,s;return i>t/a?(r=t,s=t/i):(s=a,r=a*i),{x:(t-r)/2,y:(a-s)/2,width:r,height:s}}static async merge({inputs:e,format:o="mp4",resolution:t,scaleMode:a="proportional",backgroundColor:n="#000000",onProgress:i}){if(!e||e.length<2)throw new Error("At least 2 videos are required for merging.");console.log("[MediaProcessor] Starting merge of",e.length,"videos");const r=[];let s=null,c=null,d=null;const l=document.createElement("canvas");try{console.log("[MediaProcessor] Step 1: Analyzing input videos...");const u=[];let p=0,f=0;for(let o=0;o<e.length;o++){const t=new MediaBunny.Input({source:new MediaBunny.BlobSource(e[o]),formats:MediaBunny.ALL_FORMATS});r.push(t);const a=await t.getPrimaryVideoTrack();if(!a)throw new Error(`No video track found in input file ${o+1}`);const n=await a.computeDuration(),s=a.displayWidth||a.codedWidth,c=a.displayHeight||a.codedHeight;console.log(`[MediaProcessor] Video ${o+1}: ${s}x${c}, ${n}s, codec: ${a.codec}`),p=Math.max(p,s),f=Math.max(f,c),u.push({index:o,input:t,width:s,height:c,duration:n,codec:a.codec}),i&&i((o+1)/(2*e.length))}const g=t?.width||p,m=t?.height||f,h=30;let y;switch(console.log(`[MediaProcessor] Target specs: ${g}x${m} @ ${h}fps`),console.log("[MediaProcessor] Step 2: Setting up output..."),o){case"mp4":y=new MediaBunny.Mp4OutputFormat;break;case"webm":y=new MediaBunny.WebMOutputFormat;break;case"mov":y=new MediaBunny.QuickTimeOutputFormat;break;default:throw new Error(`Unsupported format: ${o}`)}s=new MediaBunny.Output({format:y,target:new MediaBunny.BufferTarget}),l.width=g,l.height=m;const w=l.getContext("2d");let M;c=new MediaBunny.CanvasSource(l,{codec:"webm"===o?"vp9":"avc",bitrate:5e6,frameRate:h}),s.addVideoTrack(c,{frameRate:h});let B=128e3;const v=48e3,P=2;if("webm"===o)M="opus";else{const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);0===e.length?(console.warn("[MediaProcessor] No supported audio codecs found, merge will be video-only"),M=null):(M=e[0],console.log(`[MediaProcessor] Using audio codec: ${M}`))}M&&(d=new MediaBunny.AudioSampleSource({codec:M,bitrate:B}),s.addAudioTrack(d),console.log(`[MediaProcessor] Audio output: ${P} channels @ ${v}Hz`)),await s.start();let k=0;for(let e=0;e<u.length;e++){console.log(`[MediaProcessor] Processing video ${e+1}/${u.length}...`);const o=u[e],t=o.input,r=await t.getPrimaryVideoTrack(),s=await t.getPrimaryAudioTrack();if(!await r.canDecode())throw new Error(`Cannot decode video ${e+1}. Codec ${r.codec} not supported.`);const l=new MediaBunny.VideoSampleSink(r),p=await r.getFirstTimestamp();let f=0;for await(const e of l.samples())try{const o=k+(e.timestamp-p),t=e.duration||1/h;w.fillStyle=n,w.fillRect(0,0,g,m);const i=MediaProcessor._calculateScale(e.displayWidth,e.displayHeight,g,m,a);e.draw(w,i.x,i.y,i.width,i.height),await c.add(o,t),f++}finally{e.close()}if(console.log(`[MediaProcessor] Processed ${f} frames from video ${e+1}`),d&&s){if(await s.canDecode()){console.log(`[MediaProcessor] Processing audio from video ${e+1}...`);const o=new MediaBunny.AudioSampleSink(s),t=await s.getFirstTimestamp();let a=0;const n=s.sampleRate!==v,i=s.numberOfChannels!==P;(n||i)&&console.log(`[MediaProcessor] Audio conversion needed: ${s.numberOfChannels}ch @ ${s.sampleRate}Hz -> ${P}ch @ ${v}Hz`);for await(const e of o.samples()){const o=k+(e.timestamp-t);let r=e;if(n||i)try{const t=new OfflineAudioContext(P,Math.ceil(e.numberOfFrames*(v/e.sampleRate)),v),a=e.toAudioBuffer(),n=t.createBufferSource();n.buffer=a,n.connect(t.destination),n.start(0);const i=await t.startRendering(),s=MediaBunny.AudioSample.fromAudioBuffer(i,o);r=Array.isArray(s)?s[0]:s,e.close()}catch(o){throw console.error("[MediaProcessor] Error resampling audio:",o),e.close(),o}else r.setTimestamp(o);await d.add(r),r!==e&&r.close(),a++}console.log(`[MediaProcessor] Processed ${a} audio samples from video ${e+1}`)}else console.warn(`[MediaProcessor] Cannot decode audio from video ${e+1}, skipping`)}else!d&&s&&console.log("[MediaProcessor] No audio encoder available, skipping audio");if(k+=o.duration,i){i(.5+(e+1)/(2*u.length))}}return console.log("[MediaProcessor] Finalizing merge..."),c.close(),d&&d.close(),await s.finalize(),i&&i(1),console.log("[MediaProcessor] Merge complete!"),new Blob([s.target.buffer],{type:`video/${o}`})}catch(e){throw console.error("[MediaProcessor] Merge failed:",e),new Error(`Video merge failed: ${e.message}`)}finally{if(console.log("[MediaProcessor] Cleaning up resources..."),s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing output during merge cleanup:",e)}if(c&&"function"==typeof c.dispose)try{c.dispose()}catch(e){console.warn("Error disposing canvasSource during merge cleanup:",e)}if(d&&"function"==typeof d.dispose)try{d.dispose()}catch(e){console.warn("Error disposing audioSource during merge cleanup:",e)}for(const e of r)if(e&&"function"==typeof e.dispose)try{e.dispose()}catch(e){console.warn("Error disposing input during merge cleanup:",e)}if(r.length=0,l){const e=l.getContext("2d");e&&e.clearRect(0,0,l.width,l.height)}s=null,c=null,d=null,console.log("[MediaProcessor] Cleanup complete")}}static async createGif(e){const{input:o,startTime:t,duration:a,fps:n,width:i,height:r,quality:s,onProgress:c}=e,d=document.createElement("video");d.muted=!0,d.playsInline=!0;const l=URL.createObjectURL(o);d.src=l;try{await new Promise((e,o)=>{d.onloadedmetadata=e,d.onerror=o});const e=document.createElement("canvas");e.width=i,e.height=r;const o=e.getContext("2d",{willReadFrequently:!0}),l=new GIF({workers:2,quality:Math.max(1,Math.round((100-s)/10)),workerScript:"assets/js/lib/gif.worker.js",width:i,height:r}),u=Math.round(1e3/n),p=Math.ceil(a*n),f=a/p;let g=0;for(let a=0;a<p;a++){const n=t+a*f;d.currentTime=n,await new Promise(e=>{d.onseeked=e}),o.drawImage(d,0,0,i,r),l.addFrame(e,{delay:u,copy:!0}),g++,c&&c(g/p*.5)}return new Promise((e,o)=>{l.on("finished",o=>{c&&c(1),e(o)}),l.on("progress",e=>{c&&c(.5+.5*e)}),l.on("error",o),l.render()})}finally{URL.revokeObjectURL(l),d.src="",d.load()}}static async reverseVideo({source:e,includeAudio:o=!1,onProgress:t}){console.log("[MediaProcessor] Starting video reversal...");const a=new MediaBunny.BlobSource(e),n=new MediaBunny.Input({source:a,formats:MediaBunny.ALL_FORMATS});let i=null,r=null,s=null;const c="undefined"!=typeof OffscreenCanvas;let d=null,l=null;try{const e=await n.getPrimaryVideoTrack();if(!e)throw new Error("No video track found");const a=e.displayWidth||e.codedWidth,u=e.displayHeight||e.codedHeight,p=await e.computeDuration();let f=30;try{f=(await e.computePacketStats()).averagePacketRate||30}catch(e){console.warn("[MediaProcessor] Could not compute frame rate, defaulting to 30fps",e)}console.log(`[MediaProcessor] Source: ${a}x${u}, ${p}s, ${f}fps`);const g=new MediaBunny.Mp4OutputFormat;if(i=new MediaBunny.Output({format:g,target:new MediaBunny.BufferTarget}),c?d=new OffscreenCanvas(a,u):(d=document.createElement("canvas"),d.width=a,d.height=u),l=d.getContext("2d",{willReadFrequently:!0}),r=new MediaBunny.CanvasSource(d,{codec:"avc",bitrate:5e6,frameRate:f}),i.addVideoTrack(r,{frameRate:f}),o){if(await n.getPrimaryAudioTrack()){const e=await MediaBunny.getEncodableAudioCodecs(["aac","opus","mp3"]);e.length>0&&(s=new MediaBunny.AudioSampleSource({codec:e[0],bitrate:128e3}),i.addAudioTrack(s))}}await i.start(),console.log("[MediaProcessor] Extracting frames...");const m=[],h=new MediaBunny.VideoSampleSink(e);let y,w,M=0;c?y=new OffscreenCanvas(a,u):(y=document.createElement("canvas"),y.width=a,y.height=u),w=y.getContext("2d");for await(const e of h.samples()){t&&t(M/(p*f)*.4),e.draw(w,0,0,a,u);const o=await createImageBitmap(y);m.push({bitmap:o,duration:e.duration||1/f}),e.close(),M++}console.log(`[MediaProcessor] Extracted ${m.length} frames`),console.log("[MediaProcessor] Encoding reversed frames..."),m.reverse();let B=0;for(let e=0;e<m.length;e++){const o=m[e];t&&t(.4+e/m.length*.5),l.drawImage(o.bitmap,0,0),await r.add(B,o.duration),B+=o.duration,o.bitmap.close()}if(o&&s){console.log("[MediaProcessor] Reversing audio...");try{const e=await n.getPrimaryAudioTrack();if(e){const o=new MediaBunny.AudioSampleSink(e),t=[];for await(const e of o.samples())t.push(e);console.log(`[MediaProcessor] Collected ${t.length} audio samples`),t.reverse();let a=0;for(const e of t){const o=await e.toAudioBuffer();for(let e=0;e<o.numberOfChannels;e++){o.getChannelData(e).reverse()}const t=MediaBunny.AudioSample.fromAudioBuffer(o,a),n=Array.isArray(t)?t:[t];for(const o of n)await s.add(o),a+=o.duration,o!==e&&o.close();e.close()}console.log("[MediaProcessor] Audio reversal complete")}}catch(e){console.warn("[MediaProcessor] Audio reversal failed:",e)}}return console.log("[MediaProcessor] Finalizing..."),r.close(),s&&s.close(),await i.finalize(),t&&t(1),new Blob([i.target.buffer],{type:"video/mp4"})}finally{if(n&&"function"==typeof n.dispose)try{n.dispose()}catch(e){console.warn("Error disposing input:",e)}if(i&&"function"==typeof i.dispose)try{i.dispose()}catch(e){console.warn("Error disposing output:",e)}if(r&&"function"==typeof r.dispose)try{r.dispose()}catch(e){console.warn("Error disposing canvasSource:",e)}if(s&&"function"==typeof s.dispose)try{s.dispose()}catch(e){console.warn("Error disposing audioSource:",e)}}}static applyChromaKey(e,o,t="transparent",a="#000000"){const n=e.data;e.width,e.height;let i=0,r=0,s=0;if("custom"===t){const e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);e&&(i=parseInt(e[1],16),r=parseInt(e[2],16),s=parseInt(e[3],16))}const c=o.map(e=>({r:e.r,g:e.g,b:e.b,similarity:void 0!==e.similarity?e.similarity:0,smoothness:void 0!==e.smoothness?e.smoothness:.08,spill:void 0!==e.spill?e.spill:.1}));for(let e=0;e<n.length;e+=4){const o=n[e],a=n[e+1],d=n[e+2];let l=1,u=o,p=a,f=d;for(const e of c){const t=Math.sqrt((o-e.r)**2+(a-e.g)**2+(d-e.b)**2)/441.67;let n=1;if(t<e.similarity?n=0:t<e.similarity+e.smoothness&&(n=(t-e.similarity)/e.smoothness),n<l&&(l=n,n<1&&e.spill>0)){const n=.299*o+.587*a+.114*d,i=e.spill*(1-t);i>0&&(u=o*(1-i)+n*i,p=a*(1-i)+n*i,f=d*(1-i)+n*i)}}"transparent"===t?(n[e]=u,n[e+1]=p,n[e+2]=f,n[e+3]=255*l):(n[e]=u*l+i*(1-l),n[e+1]=p*l+r*(1-l),n[e+2]=f*l+s*(1-l),n[e+3]=255)}}}