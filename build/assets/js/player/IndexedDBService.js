export class IndexedDBService{constructor(){this.DB_NAME="JellyJumpDB",this.DB_VERSION=1,this.STORES={PLAYLIST:"playlist",FILES:"files",STATE:"state"},this.db=null,this.initPromise=this._init()}_init(){return new Promise((e,t)=>{const i=indexedDB.open(this.DB_NAME,this.DB_VERSION);i.onerror=e=>{console.error("IndexedDB error:",e.target.error),t(e.target.error)},i.onsuccess=t=>{this.db=t.target.result,e(this.db)},i.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this.STORES.PLAYLIST)||t.createObjectStore(this.STORES.PLAYLIST,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.FILES)||t.createObjectStore(this.STORES.FILES,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.STATE)||t.createObjectStore(this.STORES.STATE,{keyPath:"key"})}})}async ready(){return this.db||await this.initPromise,this.db}async savePlaylist(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaylist"),Promise.resolve()):new Promise((t,i)=>{const s=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES],"readwrite");s.oncomplete=()=>{e.length>0?localStorage.setItem(this.DB_NAME+"-playlist","true"):localStorage.removeItem(this.DB_NAME+"-playlist");for(const t of e)t.isLocal&&t.file&&(console.log(`[IndexedDB] Releasing memory for persisted file: ${t.title}`),t.file=null);t()},s.onerror=e=>i(e.target.error);const o=s.objectStore(this.STORES.PLAYLIST),r=s.objectStore(this.STORES.FILES);o.clear(),e.forEach(e=>{const t={id:e.id,title:e.title,duration:e.duration,thumbnail:e.thumbnail,isLocal:e.isLocal,path:e.path,url:e.isLocal?"":e.url,originalIndex:e.originalIndex,fileSize:e.fileSize,fileType:e.fileType};if(o.put(t),e.isLocal&&e.file){const t=524288e3;e.file.size<t?r.put({id:e.id,blob:e.file,name:e.file.name||e.title,type:e.file.type}):console.warn(`[IndexedDB] File ${e.title} too large to persist (${(e.file.size/1024/1024).toFixed(2)} MB)`)}})})}async loadPlaylist(){return await this.ready(),new Promise((e,t)=>{const i=this.db.transaction([this.STORES.PLAYLIST],"readonly").objectStore(this.STORES.PLAYLIST).getAll();i.onsuccess=()=>{const t=i.result.map(e=>{const t={...e};return t.isLocal&&(t.file=null,t.url=null,t.needsReload=!1),t});e(t)},i.onerror=()=>t(i.error)})}async loadFile(e){return await this.ready(),new Promise((t,i)=>{const s=this.db.transaction([this.STORES.FILES],"readonly").objectStore(this.STORES.FILES).get(e);s.onsuccess=()=>{const e=s.result;if(e){const i=new File([e.blob],e.name,{type:e.type});t(i)}else t(null)},s.onerror=()=>i(s.error)})}async saveFile(e,t,i,s){await this.ready();return t.size>524288e3?(console.warn(`[IndexedDB] File too large to save: ${(t.size/1024/1024).toFixed(2)} MB`),!1):new Promise((o,r)=>{const a=this.db.transaction([this.STORES.FILES],"readwrite");a.objectStore(this.STORES.FILES).put({id:e,blob:t,name:i,type:s}),a.oncomplete=()=>{console.log(`[IndexedDB] File saved: ${i} (${(t.size/1024/1024).toFixed(2)} MB)`),o(!0)},a.onerror=()=>r(a.error)})}async savePlaybackState(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaybackState"),Promise.resolve()):new Promise((t,i)=>{const s=this.db.transaction([this.STORES.STATE],"readwrite");s.objectStore(this.STORES.STATE).put({key:"playback",...e}),s.oncomplete=()=>t(),s.onerror=()=>i(s.error)})}async loadPlaybackState(){return await this.ready(),new Promise((e,t)=>{const i=this.db.transaction([this.STORES.STATE],"readonly").objectStore(this.STORES.STATE).get("playback");i.onsuccess=()=>e(i.result),i.onerror=()=>t(i.error)})}async clear(){await this.ready();const e=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES,this.STORES.STATE],"readwrite");return e.objectStore(this.STORES.PLAYLIST).clear(),e.objectStore(this.STORES.FILES).clear(),e.objectStore(this.STORES.STATE).clear(),new Promise(t=>{e.oncomplete=()=>{localStorage.removeItem(this.DB_NAME+"-playlist"),t()}})}}