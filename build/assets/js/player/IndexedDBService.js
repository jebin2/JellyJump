export class IndexedDBService{constructor(){this.DB_NAME="JellyJumpDB",this.DB_VERSION=1,this.STORES={PLAYLIST:"playlist",FILES:"files",STATE:"state"},this.db=null,this.initPromise=this._init()}_init(){return new Promise((e,t)=>{const s=indexedDB.open(this.DB_NAME,this.DB_VERSION);s.onerror=e=>{console.error("IndexedDB error:",e.target.error),t(e.target.error)},s.onsuccess=t=>{this.db=t.target.result,e(this.db)},s.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this.STORES.PLAYLIST)||t.createObjectStore(this.STORES.PLAYLIST,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.FILES)||t.createObjectStore(this.STORES.FILES,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.STATE)||t.createObjectStore(this.STORES.STATE,{keyPath:"key"})}})}async ready(){return this.db||await this.initPromise,this.db}async savePlaylist(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaylist"),Promise.resolve()):new Promise((t,s)=>{const r=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES],"readwrite");r.oncomplete=()=>{e.length>0?localStorage.setItem(this.DB_NAME+"-playlist","true"):localStorage.removeItem(this.DB_NAME+"-playlist"),t()},r.onerror=e=>s(e.target.error);const i=r.objectStore(this.STORES.PLAYLIST),o=r.objectStore(this.STORES.FILES);i.clear(),e.forEach(e=>{const t={id:e.id,title:e.title,duration:e.duration,thumbnail:e.thumbnail,isLocal:e.isLocal,path:e.path,url:e.isLocal?"":e.url,originalIndex:e.originalIndex};if(i.put(t),e.isLocal&&e.file){const t=524288e3;e.file.size<t?o.put({id:e.id,blob:e.file,name:e.file.name||e.title,type:e.file.type}):console.warn(`[IndexedDB] File ${e.title} too large to persist (${(e.file.size/1024/1024).toFixed(2)} MB)`)}})})}async loadPlaylist(){return await this.ready(),new Promise((e,t)=>{const s=this.db.transaction([this.STORES.PLAYLIST],"readonly").objectStore(this.STORES.PLAYLIST).getAll();s.onsuccess=()=>{const t=s.result.map(e=>{const t={...e};return t.isLocal&&(t.file=null,t.url=null,t.needsReload=!1),t});e(t)},s.onerror=()=>t(s.error)})}async loadFile(e){return await this.ready(),new Promise((t,s)=>{const r=this.db.transaction([this.STORES.FILES],"readonly").objectStore(this.STORES.FILES).get(e);r.onsuccess=()=>{const e=r.result;if(e){const s=new File([e.blob],e.name,{type:e.type});t(s)}else t(null)},r.onerror=()=>s(r.error)})}async saveFile(e,t,s,r){await this.ready();return t.size>524288e3?(console.warn(`[IndexedDB] File too large to save: ${(t.size/1024/1024).toFixed(2)} MB`),!1):new Promise((i,o)=>{const a=this.db.transaction([this.STORES.FILES],"readwrite");a.objectStore(this.STORES.FILES).put({id:e,blob:t,name:s,type:r}),a.oncomplete=()=>{console.log(`[IndexedDB] File saved: ${s} (${(t.size/1024/1024).toFixed(2)} MB)`),i(!0)},a.onerror=()=>o(a.error)})}async savePlaybackState(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaybackState"),Promise.resolve()):new Promise((t,s)=>{const r=this.db.transaction([this.STORES.STATE],"readwrite");r.objectStore(this.STORES.STATE).put({key:"playback",...e}),r.oncomplete=()=>t(),r.onerror=()=>s(r.error)})}async loadPlaybackState(){return await this.ready(),new Promise((e,t)=>{const s=this.db.transaction([this.STORES.STATE],"readonly").objectStore(this.STORES.STATE).get("playback");s.onsuccess=()=>e(s.result),s.onerror=()=>t(s.error)})}async clear(){await this.ready();const e=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES,this.STORES.STATE],"readwrite");return e.objectStore(this.STORES.PLAYLIST).clear(),e.objectStore(this.STORES.FILES).clear(),e.objectStore(this.STORES.STATE).clear(),new Promise(t=>{e.oncomplete=()=>{localStorage.removeItem(this.DB_NAME+"-playlist"),t()}})}}