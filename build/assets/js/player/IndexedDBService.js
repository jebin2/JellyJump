export class IndexedDBService{constructor(){this.DB_NAME="JellyJumpDB",this.DB_VERSION=1,this.STORES={PLAYLIST:"playlist",FILES:"files",STATE:"state"},this.db=null,this.initPromise=this._init()}_init(){return new Promise((e,t)=>{const s=indexedDB.open(this.DB_NAME,this.DB_VERSION);s.onerror=e=>{console.error("IndexedDB error:",e.target.error),t(e.target.error)},s.onsuccess=t=>{this.db=t.target.result,e(this.db)},s.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains(this.STORES.PLAYLIST)||t.createObjectStore(this.STORES.PLAYLIST,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.FILES)||t.createObjectStore(this.STORES.FILES,{keyPath:"id"}),t.objectStoreNames.contains(this.STORES.STATE)||t.createObjectStore(this.STORES.STATE,{keyPath:"key"})}})}async ready(){return this.db||await this.initPromise,this.db}async savePlaylist(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaylist"),Promise.resolve()):new Promise((t,s)=>{const r=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES],"readwrite");r.oncomplete=()=>{e.length>0?localStorage.setItem(this.DB_NAME+"-playlist","true"):localStorage.removeItem(this.DB_NAME+"-playlist"),t()},r.onerror=e=>s(e.target.error);const i=r.objectStore(this.STORES.PLAYLIST),o=r.objectStore(this.STORES.FILES);i.clear(),o.clear(),e.forEach(e=>{const t={id:e.id,title:e.title,duration:e.duration,thumbnail:e.thumbnail,isLocal:e.isLocal,path:e.path,url:e.isLocal?"":e.url,originalIndex:e.originalIndex};i.put(t),e.isLocal&&e.file&&(e.file.size<524288e3?o.put({id:e.id,blob:e.file,name:e.file.name,type:e.file.type}):console.warn(`File ${e.title} too large to persist (${(e.file.size/1024/1024).toFixed(2)} MB)`))})})}async loadPlaylist(){return await this.ready(),new Promise((e,t)=>{const s=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES],"readonly"),r=s.objectStore(this.STORES.PLAYLIST),i=s.objectStore(this.STORES.FILES),o=r.getAll();o.onsuccess=async()=>{const s=o.result,r=[],a=i.getAll();a.onsuccess=()=>{const t=a.result,i=new Map(t.map(e=>[e.id,e]));s.forEach(e=>{const t={...e};if(t.isLocal){const s=i.get(e.id);s?(t.file=new File([s.blob],s.name,{type:s.type}),t.url=URL.createObjectURL(t.file),t.needsReload=!1):t.needsReload=!0}r.push(t)}),e(r)},a.onerror=()=>t(a.error)},o.onerror=()=>t(o.error)})}async savePlaybackState(e){return await this.ready(),!this.db||this.db.statechanged?(console.warn("IndexedDB connection not available, skipping savePlaybackState"),Promise.resolve()):new Promise((t,s)=>{const r=this.db.transaction([this.STORES.STATE],"readwrite");r.objectStore(this.STORES.STATE).put({key:"playback",...e}),r.oncomplete=()=>t(),r.onerror=()=>s(r.error)})}async loadPlaybackState(){return await this.ready(),new Promise((e,t)=>{const s=this.db.transaction([this.STORES.STATE],"readonly").objectStore(this.STORES.STATE).get("playback");s.onsuccess=()=>e(s.result),s.onerror=()=>t(s.error)})}async clear(){await this.ready();const e=this.db.transaction([this.STORES.PLAYLIST,this.STORES.FILES,this.STORES.STATE],"readwrite");return e.objectStore(this.STORES.PLAYLIST).clear(),e.objectStore(this.STORES.FILES).clear(),e.objectStore(this.STORES.STATE).clear(),new Promise(t=>{e.oncomplete=()=>{localStorage.removeItem(this.DB_NAME+"-playlist"),t()}})}}